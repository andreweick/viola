Requirements: viola (Go library and CLI)

A Go module that loads and saves TOML configuration while encrypting selected values with age in ASCII-armored blocks embedded directly in the TOML file. It also emits an ASCII-art QR code of each ciphertext for easy out-of-band transfer/recovery. Designed primarily as a library (can include an optional thin CLI).

# üé≠ viola

`viola` is a command-line utility for maintaining and creating **encrypted TOML configuration files** using [age](https://github.com/FiloSottile/age).

Why **Viola**? The name comes from Shakespeare‚Äôs *Twelfth Night*. Viola is a character who **conceals her identity** in order to safely move between worlds. She appears in one form publicly, while her true self is hidden, revealed only to those who can see past the disguise.

That metaphor is exactly what `viola` does for your configs:
- **Public face** ‚Üí easy to version-control, store, and share (encrypted TOML).
- **True identity** ‚Üí the cleartext secrets, visible only when unlocked with your `age` key.
- **Transformation** ‚Üí like Viola‚Äôs disguise, `viola` allows config files to take on a safe, portable form.

---

## ‚ú® Features
- Encrypts and decrypts TOML config files with **age**.
- Keeps secrets safe while enabling them to be committed to Git.
- Designed for **immutable infrastructure**: generate once, deploy everywhere.
- Lightweight: a single binary with no external dependencies.

---

## üîê Acronym
`viola` also works as a backronym that reflects its purpose:

**V.I.O.L.A.**
- **V**ersatile
- **I**mmutable
- **O**bscured
- **L**oader for
- **A**rchives


‚∏ª

	1.	Goals & Non-Goals

Goals
	‚Ä¢	Allow humans to manually edit most of the TOML, while specific keys are encrypted at rest.
	‚Ä¢	Use age for cryptography (X25519 recipients as default; optionally add an age-scrypt passphrase recipient).
	‚Ä¢	Automatically encrypt any TOML key whose name starts with ‚Äúprivate_‚Äù (at any nesting depth).
	‚Ä¢	Support arbitrary value types (string, number, bool, array, inline table): serialize to canonical JSON first, encrypt the JSON bytes, and store the ASCII-armored age block as a TOML multiline string.
	‚Ä¢	Provide easy decryption in memory for applications; no external binaries required at runtime.
	‚Ä¢	For every encrypted field, generate a monospace ASCII-art QR code of the armored ciphertext. Place it as TOML comments adjacent to the value, and expose it via metadata.
	‚Ä¢	Be idempotent: re-saving should not re-encrypt existing values unless the plaintext changed.
	‚Ä¢	Minimal, stable, dependency-light; pure Go runtime.

Non-Goals
	‚Ä¢	Not a full secrets manager or KMS.
	‚Ä¢	No built-in cloud KMS support.
	‚Ä¢	No guarantee to preserve arbitrary user comments or key ordering in TOML.

‚∏ª

	2.	Recipients & Encryption Model

	‚Ä¢	Default: encrypt to recipients (age X25519 public keys).
	‚Ä¢	Multiple recipients can be included; all listed can decrypt.
	‚Ä¢	Self-encryption: if no recipients are provided, encrypt to the app‚Äôs own identity (generated on first run and stored in $XDG_CONFIG_HOME//age/keys.txt).
	‚Ä¢	Optional passphrase recipient (age-scrypt): if configured, include a passphrase recipient for break-glass recovery. A PassphraseProvider callback supplies the passphrase when needed.
	‚Ä¢	Rotation: add new recipients and save ‚Üí ciphertext decryptable by old and new. Later prune old recipients.
	‚Ä¢	Metadata: record which recipients and whether a passphrase was included; store in TOML comments near the QR and expose in metadata.

‚∏ª

	3.	Module Layout

/internal/qr        ‚Äì QR rendering (ASCII)
/internal/walk      ‚Äì Generic tree walker over parsed TOML
/pkg/enc            ‚Äì age helpers (encrypt/decrypt, armor)
/pkg/viola          ‚Äì Public API (Load/Save/Transform)
/cmd/viola          ‚Äì Optional thin CLI

‚∏ª

	4.	Public API (viola)

KeySources:
	‚Ä¢	IdentitiesFile: path to age private key(s)
	‚Ä¢	IdentitiesData: optional in-memory keys
	‚Ä¢	RecipientsFile: path to recipients
	‚Ä¢	Recipients: explicit recipient strings
	‚Ä¢	PassphraseProvider: callback for passphrase

Options:
	‚Ä¢	Keys: KeySources
	‚Ä¢	PrivatePrefix: default ‚Äúprivate_‚Äù
	‚Ä¢	ShouldEncrypt: optional function override
	‚Ä¢	EmitASCIIQR: default true
	‚Ä¢	QRCommentPrefix: default ‚Äú# ‚Äú
	‚Ä¢	Indent: default two spaces

FieldMeta:
	‚Ä¢	Path: slice of key names
	‚Ä¢	WasEncrypted: bool
	‚Ä¢	Armored: ASCII-armored payload
	‚Ä¢	ASCIIQR: QR as ASCII string
	‚Ä¢	UsedRecipients: list of recipients used
	‚Ä¢	UsedPassphrase: bool

Result:
	‚Ä¢	Tree: decrypted config tree (native Go types)
	‚Ä¢	Fields: metadata for each encrypted field

Functions:
	‚Ä¢	Load([]byte, Options) ‚Üí *Result
	‚Ä¢	Save(tree, Options) ‚Üí ([]byte TOML, []FieldMeta, error)
	‚Ä¢	Transform([]byte, Options, func(tree any) error) ‚Üí ([]byte, []FieldMeta, error)

‚∏ª

	5.	File Format (output TOML)

Example for private_client_secret:

QR code of ciphertext as ASCII

‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚Ä¶ (many rows)

recipients: age1abc‚Ä¶, age1xyz‚Ä¶

passphrase: no

private_client_secret = ‚Äú‚Äù‚Äù
‚Äî‚ÄìBEGIN AGE ENCRYPTED FILE‚Äî‚Äì
YWdlLWVuY3J5cHRpb24ub3JnL3Yx
‚Ä¶ full ASCII armor ‚Ä¶
‚Äî‚ÄìEND AGE ENCRYPTED FILE‚Äî‚Äì
‚Äú‚Äù‚Äù

‚∏ª

	6.	Behavior Details

	‚Ä¢	Encrypt keys that start with PrivatePrefix or match ShouldEncrypt.
	‚Ä¢	At any depth (tables, arrays of tables).
	‚Ä¢	Non-scalars serialized to JSON before encryption.
	‚Ä¢	Already encrypted values left unchanged unless plaintext changed.
	‚Ä¢	Load detects armored blocks, decrypts with identities/passphrase, and JSON-decodes back into Go values.
	‚Ä¢	Arrays/tables: only encrypt fields, not whole element.

‚∏ª

	7.	ASCII QR

	‚Ä¢	QR encodes the entire ASCII-armored payload.
	‚Ä¢	Rendered as text using dark=‚ñà and light=space.
	‚Ä¢	Quiet zone included.
	‚Ä¢	Configurable comment prefix.
	‚Ä¢	Should scale down automatically to fit typical terminal widths.

‚∏ª

	8.	Dependencies

	‚Ä¢	github.com/burntsushi: TOML
   	* https://github.com/urfave/cli: command line parsing
	‚Ä¢	filippo.io/age and filippo.io/age/armor
	‚Ä¢	github.com/skip2/go-qrcode (or minimal QR encoder)
	‚Ä¢	encoding/json from stdlib
* https://github.com/charmbracelet/bubbletea and https://github.com/charmbracelet/lipgloss

No CGO, no external binaries.

‚∏ª

	9.	Errors & Edge Cases

	‚Ä¢	Save without any recipients or self identity ‚Üí error.
	‚Ä¢	Load without identities/passphrase for encrypted values ‚Üí error (include key path).
	‚Ä¢	Malformed armor ‚Üí error.
	‚Ä¢	JSON encode/decode errors propagate.
	‚Ä¢	Numbers: use json.Number to preserve int/float.
	‚Ä¢	Normalize line endings in armor.

‚∏ª

	10.	Security Considerations

	‚Ä¢	Confidentiality and integrity from age AEAD.
	‚Ä¢	Never log plaintext.
	‚Ä¢	Zero buffers best-effort.
	‚Ä¢	Identity files chmod 0600, directories 0700.
	‚Ä¢	Enforce strong passphrase if used.

‚∏ª

	11.	Performance

	‚Ä¢	Configs are small; no special tuning needed.
	‚Ä¢	Work is per-field.
	‚Ä¢	QR generation is O(n) in ciphertext size; can be disabled.

‚∏ª

	12.	Testing & Acceptance Criteria

	‚Ä¢	Unit tests for round-trip on all types (string, int, bool, array, table).
	‚Ä¢	Nested and multiple private_ keys.
	‚Ä¢	Idempotent save behavior.
	‚Ä¢	Failures when recipients/identities missing.
	‚Ä¢	Golden tests: expected TOML with QR and recipient lines.
	‚Ä¢	Fuzz tests: random trees with random private_ keys.
	‚Ä¢	Example tests compile and run.

‚∏ª

Safe defaults: output to stdout unless explicitly writing in place.

‚∏ª
